// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// TODOS: 
// - ENROLLEMENT and GROUP INVITES AND REQUESTS 
// - NOTIFICATION STATUSES? 
// - SUBMISSION, PEER REVIEW, INSTRUCTOR REVIEW, GROUP REVIEW STATUSES?

// User Models

// model Student {
//   studentId                 String             @id @default(uuid())
//   username                  String             @unique
//   password                  String
//   email                     String             @unique
//   firstname                 String
//   lastname                  String
//   classes                   StudentInClass[] // Retrieve Assignments based on classes they are. 
//   submissions               Submission[]
//   peerReviewsDone           PeerReview[]       @relation("Reviewer")
//   peerReviewsRecieved       PeerReview[]       @relation("Reviewee")
//   instructorReviewsRecieved InstructorReview[] @relation("RevieweeStudent")
//   studentGroups             StudentInGroup[]
//   GroupSubmission           GroupSubmission[]  @relation("SubmittedByStudent")
// }

model User {
  userId            String          @id @default(uuid())
  email             String          @unique
  password          String
  firstname         String
  lastname          String
  isEmailVerified   Boolean         @default(false)
  isRoleActivated   Boolean         @default(false)
  createdAt         DateTime        @default(now())
  //updatedAt         DateTime        @updatedAt
  role              UserRole        @default(STUDENT)
  classes           UserInClass[]
  submissions       Submission[]
  reviewsDone       Review[]        @relation("Reviewer")
  reviewsRecieved   Review[]        @relation("Reviewee")
  classesInstructed Class[]         @relation("InstructorClasses")
  groups            Group[]
  groupCriteria     Criterion[]
  RoleRequest       RoleRequest?
  enrollRequests    EnrollRequest[]
  notifications     Notification[]  @relation("ReceiverNotifications")
  sentNotifications Notification[]  @relation("SenderNotifications")
}

// // Need to refactor last references to others tables, depending on what we want instructors to be able to pull up
// model Instructor {
//   instructorId      String             @id @default(uuid())
//   username          String             @unique
//   password          String
//   email             String             @unique
//   firstname         String
//   lastname          String
//   // isAdmin            Boolean             @default(false) // Create separate admin model?
//   classes           Class[]            @relation("TaughtBy") // Classes the instructor is teaching
//   rubricsCreated    Rubric[]           @relation("RubricCreatedByInstructor") // Rubrics created by the instructor
//   instructorReviews InstructorReview[] @relation("ReviewerInstructor")
// }

// Admin General Crud operations 

// Class and Assignment Models

model Class {
  classId       String          @id @default(uuid())
  instructorId  String
  classname     String
  description   String
  startDate     DateTime
  endDate       DateTime
  term          String?
  classSize     Int?            @default(5)
  groups        Group[]
  usersInClass  UserInClass[]
  Assignments   Assignment[]
  categories    Category[] // Add this line
  instructor    User            @relation("InstructorClasses", fields: [instructorId], references: [userId]) // Only one instructor per class 
  EnrollRequest EnrollRequest[]
  rubrics       Rubric[]
}

model UserInClass {
  userId  String
  classId String
  user    User   @relation(fields: [userId], references: [userId], onDelete: Cascade)
  class   Class  @relation(fields: [classId], references: [classId], onDelete: Cascade)

  @@id([userId, classId], name: "UserInClassId")
}

// Removing, Single instructor for a class, Admin can which instructors are associated with a class

// model InstructorInClass {
//   instructorId String
//   classId      String
//   Instructor   Instructor @relation(fields: [instructorId], references: [instructorId])
//   Class        Class      @relation(fields: [classId], references: [classId])

//   @@id([instructorId, classId])
// }

// Make a many to many relationship with rubric 
model Assignment {
  assignmentId       String                @id @default(uuid())
  classId            String
  title              String
  description        String?
  dueDate            DateTime
  maxSubmissions     Int                   @default(1)
  isGroup            Boolean               @default(false)
  isGroupReview      Boolean?               @default(false)
  dueDateGroupReview DateTime?
  isPeerReview       Boolean               @default(false)
  dueDateReview      DateTime?
  numReviewsRequired Int?               @default(1)
  assignmentType     SubmissionType        @default(URL)
  assignmentFilePath String?
  classes            Class                 @relation(fields: [classId], references: [classId], onDelete: Cascade)
  categoryId         String? // Add this line
  category           Category?             @relation(fields: [categoryId], references: [categoryId]) // Add this line
  rubric             Rubric[]             
  submissions        Submission[]
  reviews            Review[]
  // Switch to the enum later
  reviewOption       String?
}

// Group Models

model Group {
  groupId          String       @id @default(uuid())
  //assignmentId     String
  classId          String
  groupName        String
  groupDescription String?
  groupSize        Int          @default(0)
  //assignment       Assignment        @relation(fields: [assignmentId], references: [assignmentId])
  class            Class        @relation(fields: [classId], references: [classId], onDelete: Cascade)
  students         User[] // Students in the group
  submissions      Submission[] // Submissions from the group
  reviews          Review[] // Reviews from the group
  rubric           Rubric[] // Rubrics for the group
}

// model StudentInGroup {
//   studentId      String
//   groupId String
//   student        Student      @relation(fields: [studentId], references: [studentId])
//   groupProject   GroupProject @relation(fields: [groupId], references: [groupId])

//   @@id([studentId, groupProjectId])
// } 

// Group Sumbission + Group Review  

// 3 Types of eval -> peer, isntructor, group

// Submission Models

model Submission {
  submissionId       String     @id @default(uuid())
  assignmentId       String
  submitterId        String?
  submitterGroupId   String?
  createdAt          DateTime   @default(now())
  updatedAt          DateTime   @updatedAt
  // submissionType     SubmissionType // Either a File or a URL, we need to discuss file storage options
  submissionFilePath String?
  finalGrade         Int? // Final grade of the Submission, default to the instructor grade?
  assignment         Assignment @relation(fields: [assignmentId], references: [assignmentId], onDelete: Cascade)
  submitter          User?      @relation(fields: [submitterId], references: [userId])
  submitterGroup     Group?     @relation(fields: [submitterGroupId], references: [groupId])
  reviews            Review[]
  submissionComment  String?
}

// model GroupSubmission {
//   submissionId       String         @id @default(uuid())
//   groupProjectId     String
//   createdAt          DateTime       @default(now())
//   updatedAt          DateTime       @updatedAt
//   submittedBy        String // The studentId of the student who made the submission
//   submissionFilePath String
// submissionType     SubmissionType // Either a File or a URL, we need to discuss file storage options
//   grade              Int? // Final grade of the Submission, Graded by the instructor)
//   // groupProject       GroupProject   @relation(fields: [groupProjectId], references: [groupProjectId])
//   submittedByUser    User           @relation("SubmittedByUser", fields: [submittedBy], references: [userId])
// }

// Review model. 

// model PeerReview {
//   peerReviewId           String                  @id @default(uuid())
//   submissionId           String
//   studentReviewerId      String
//   revieweeId             String
//   createdAt              DateTime                @default(now())
//   updatedAt              DateTime                @updatedAt
//   peerReviewGrade        Int // Total grade of the review = sum of reviewerCriteronGrades
//   submission             Submission              @relation(fields: [submissionId], references: [submissionId])
//   reviewerStudent        Student                 @relation("Reviewer", fields: [studentReviewerId], references: [studentId])
//   reviewee               Student                 @relation("Reviewee", fields: [revieweeId], references: [studentId])
//   reviewerCriteronGrades StudentCriterionGrade[]
// }

// Way to check if all students have submitted their group reivew,  
// and if not, send a reminder to the students who haven't submitted  

// Group Review is 

model Review {
  reviewId        String           @id @default(uuid())
  assignmentId    String
  submissionId    String?
  reviewerId      String
  revieweeId      String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  isGroup         Boolean          @default(false)
  isPeerReview    Boolean          @default(false)
  reviewType      ReviewTypeEnum   @default(INSTRUCTOR)
  reviewGrade     Int // Total grade of the review = sum of reviewerCriteronGrades
  //Group-specific fields (if isGroup is true)
  groupId         String?
  rubricId        String?

  group           Group?           @relation(fields: [groupId], references: [groupId])
  rubric          Rubric?          @relation(fields: [rubricId], references: [rubricId])
  assignment      Assignment       @relation(fields: [assignmentId], references: [assignmentId], onDelete: Cascade)
  submission      Submission?       @relation(fields: [submissionId], references: [submissionId], onDelete: Cascade)
  reviewer        User             @relation("Reviewer", fields: [reviewerId], references: [userId])
  reviewee        User?             @relation("Reviewee", fields: [revieweeId], references: [userId])
  criterionGrades CriterionGrade[]
}

// Way to check if all students have submitted their group reivew,  
// and if not, send a reminder to the students who haven't submitted  

// Group Review is 

// model InstructorReview {
//   instructorReviewId       String                     @id @default(uuid())
//   submissionId             String
//   instructorReviewerId     String
//   revieweeId               String
//   createdAt                DateTime                   @default(now())
//   updatedAt                DateTime                   @updatedAt
//   instructorReviewGrade    Int // Total grade of the review = sum of instructorCriteronGrades
//   submission               Submission                 @relation(fields: [submissionId], references: [submissionId], onDelete: Cascade)
//   reviewerInstructor       Instructor                 @relation("ReviewerInstructor", fields: [instructorReviewerId], references: [instructorId])
//   reviewee                 Student                    @relation("RevieweeStudent", fields: [revieweeId], references: [studentId])
//   instructorCriterionGrade InstructorCriterionGrade[]
// }

// TODO refactor / reimplment GroupReview

// model GroupReview {
//   groupReviewId        String           @id @default(uuid())
//   groupId              String
//   rubricId             String
//   assignmentId    String
//   submissionId    String
//   reviewerId      String
//   revieweeId      String
//   createdAt       DateTime         @default(now())
//   updatedAt       DateTime         @updatedAt
//   reviewType      ReviewTypeEnum   @default(INSTRUCTOR)
//   reviewGrade     Int // Total grade of the review = sum of reviewerCriteronGrades
//   group           Group            @relation(fields: [groupId], references: [groupId], onDelete: Cascade)
//   rubric          Rubric           @relation(fields: [rubricId], references: [rubricId], onDelete: Cascade)
//   assignment      Assignment       @relation(fields: [assignmentId], references: [assignmentId], onDelete: Cascade)
//   submission      Submission       @relation(fields: [submissionId], references: [submissionId], onDelete: Cascade)
//   reviewer        User?            @relation("Reviewer", fields: [reviewerId], references: [userId])
//   reviewee        User             @relation("Reviewee", fields: [revieweeId], references: [userId])
//   criterionGrades CriterionGrade[]
// }

// model GroupReview {
//   groupReviewId     String       @id @default(uuid())
//   groupProjectId    String
//   rubricId          String
//   studentReviewerId String
//   revieweeId        String
//   createdAt         DateTime     @default(now())
//   updatedAt         DateTime     @updatedAt
//   reviewerStudent   Student     @relation("Reviewer", fields: [studentReviewerId], references: [studentId])
//   revieweeStudent   Student     @relation("Reviewee", fields: [revieweeId], references: [studentId])
//   groupProject      GroupProject @relation(fields: [groupProjectId], references: [groupProjectId])
// }

// Rubric and Criterion Models

// Make a many to many relationship with assignment
model Rubric {
  rubricId    String                @id @default(uuid())
  creatorId   String
  classId   String?
  title       String
  description String?
  isGroupReviewRubric     Boolean               @default(false)
  groupId     String?
  group       Group?                @relation(fields: [groupId], references: [groupId])
  totalMarks  Int // Total marks of the rubric? Not sure if this is needed or not 
  // We may not need this
  // createdBy   User                  @relation(fields: [creatorId], references: [userId])
  reviews     Review[]
  criteria       Criterion[]
  assignments    Assignment[]

  // GroupSubmission     GroupSubmission[]
  class       Class?                @relation(fields: [classId], references: [classId], onDelete: Cascade)
}

// model RubricForAssignment {
//   assignmentId String
//   rubricId     String
//   assignment   Assignment @relation(fields: [assignmentId], references: [assignmentId])
//   rubric       Rubric     @relation(fields: [rubricId], references: [rubricId])

//   @@id([assignmentId, rubricId], name: "RubricForAssignmentId")
// }

model Criterion {
  criterionId      String            @id @default(uuid())
  rubricId         String
  title            String
  userId           String?
  maxMark          Int
  minMark          Int
  rubric           Rubric            @relation(fields: [rubricId], references: [rubricId])
  user             User?              @relation(fields: [userId], references: [userId])
  criterionRatings CriterionRating[]
  criterionGrades  CriterionGrade[]
}

model CriterionRating {
  criterionRatingId String    @id @default(uuid())
  criterionId       String
  description       String
  points            Int
  criterion         Criterion @relation(fields: [criterionId], references: [criterionId], onDelete: Cascade)
}

// Criterion Grade Models

model CriterionGrade {
  criterionGradeId String    @id @default(uuid())
  reviewId         String
  criterionId      String
  grade            Int
  comment          String? // Add this field for comments
  review           Review    @relation(fields: [reviewId], references: [reviewId])
  criterion        Criterion @relation(fields: [criterionId], references: [criterionId], onDelete: Cascade)

  @@unique([criterionId, reviewId], name: "UniqueCriteronGradePerReview") // Ensure unique combination of criterionId and reviewId
}

// model StudentCriterionGrade {
//   studentCriteronGradeId String     @id @default(uuid())
//   criterionId            String
//   peerReviewId           String
//   grade                  Int
//   textEntry              String
//   criterion              Criterion  @relation(fields: [criterionId], references: [criterionId])
//   peerReview             PeerReview @relation(fields: [peerReviewId], references: [peerReviewId])
// }

// model InstructorCriterionGrade {
//   instructorCriteronGradeId String           @id @default(uuid())
//   criterionId               String
//   instructorReviewId        String
//   grade                     Int
//   textEntry                 String
//   criterion                 Criterion        @relation(fields: [criterionId], references: [criterionId])
//   instructorReview          InstructorReview @relation(fields: [instructorReviewId], references: [instructorReviewId])
// }

// Todo 
// Enroll links to clases and enrollRequests
// Todo 
// EnrollRequest links to Enroll and students

// TODO
// Request / Status Models 
// I.e. Enrollment, Group Invites, Intructor to Admin Requests  
model RoleRequest {
  roleRequestId String        @id @default(uuid())
  userId        String
  roleRequested UserRole
  status        RequestStatus @default(PENDING)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  user          User          @relation(fields: [userId], references: [userId], onDelete: Cascade)

  @@unique([userId], name: "UniqueRoleRequestPerUser")
}

// Initial implementation - Abdul
model Notification {
  notificationId String   @id @default(uuid())
  receiverId     String
  title          String
  content        String
  senderId       String?
  type           String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  seen           Boolean? @default(false)
  receiver       User     @relation("ReceiverNotifications", fields: [receiverId], references: [userId], onDelete: Cascade)
  sender         User?    @relation("SenderNotifications", fields: [senderId], references: [userId], onDelete: Cascade)
}

model EnrollRequest {
  enrollRequestId  String        @id @default(uuid())
  userId           String
  classId          String
  status           RequestStatus @default(PENDING)
  senderMessage    String?
  recipientMessage String?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  user             User          @relation(fields: [userId], references: [userId], onDelete: Cascade)
  class            Class         @relation(fields: [classId], references: [classId], onDelete: Cascade)

  @@unique([userId, classId], name: "UniqueEnrollRequestPerUser")
}

model Category {
  categoryId  String       @id @default(uuid())
  classId     String
  name        String
  class       Class        @relation(fields: [classId], references: [classId], onDelete: Cascade)
  assignments Assignment[]
}

enum UserRole {
  INSTRUCTOR
  ADMIN
  STUDENT
}

enum RequestStatus {
  PENDING
  APPROVED
  DENIED
}

enum SubmissionType {
  FILE
  URL
}

enum ReviewType {
  MANUAL
  AUTO
}

enum ReviewTypeEnum {
  INSTRUCTOR
  PEER
  GROUP
}